
Garbage Collection（GC）是一种自动管理内存的方式，支持GC的语言无需手动管理内存
https://mp.weixin.qq.com/s/5nNd7LqdqVvHDgzDA3Ug5Q



一、程序垃圾回收机制分类：
    1）引用计数
    2）标记删除
    3）三色标记（案例：Golang采用这种方式）
    4）分代收集（案例：Java的新生代，老年代，一代，二代）

二、当前Go GC特征
    三色标记，并发标记和清扫、非分代、非紧缩、混合写屏障

三、GC关心什么？
    程序吞吐量
    GC吞吐量
    堆内存开销
    停顿时间
    停顿频率
    停顿分布
    分配性能：
    压缩：
    并发：
    伸缩：
    调优：
    预热时间：
    页释放：


四、三色标记：
    4.1



    4.2 三色状态（runtime.markBit）: Go的对象是分配到span中，span中有一个字段是 gcmarkBits, mark阶段里面每个bit代表一个slot已被标记
        白色对象该 bit为0
        灰色和黑色 bit为1

五、怎么把垃圾找出来？
1）方法：
    从根处扫描，把所有的根扫描完，每个根扫描到底。
按照之前的三色标记来说，扫描完了的是黑色，正在扫描的是灰色的，没扫描的是白色的。
根扫描完了，那么最后只会剩下两种颜色的，黑色，白色。白色就是没用的垃圾，这种清理掉就没事

2）两个问题：
    a. 那么根是什么？
        栈是根，是扫描的起点，还有一些全局变量也是根，是起点
    b. 回收的内存是哪里的内存？
        所谓垃圾只对于堆上内存来说，栈上内存是编译器管理的，堆上内存是业务分配，垃圾回收器回收

六、内存屏障

    思考：怎么扫描是安全的？
        Note：最简单的思路，我让世界都停止下来（stw），谁都别动，等我把垃圾找出来，你再运行你的程序吧。这就安全了
        问题：这种实现非常简单也易于理解，但是无法适用于生产环境，你一停整个程序，就要暂停业务，一停就几秒

    1）解决方法：内存屏障
        golang 内存屏障也有一个演进过程：
            a. 插入写屏障
            b. 删除写屏障
            c. 混合写屏障（插入写屏障 + 删除写屏障）

        区别: （hook的生成时机不同）
            内存屏障其实就是编译器帮你生成的一段 hook 代码，这三个屏障的本质区别就是 hook 的时机不同而已

    2）屏障的本质：
        1. 内存屏障只是对应一段特殊的代码
        2. 内存屏障这段代码在 "编译期间" 生成
        3. 内存屏障本质上在 "运行期间" 拦截内存写操作，相当于一个 hook 调用

    3）屏障的作用：
        a. 通过 hook 内存的写操作时机，阻止一些事情的发生，或者说做好一些标记工作，从而保证垃圾回收的正确性

七、写屏障
    1. 写屏障到底做了什么？
        a. hook 写操作
        b. hook 写操作之后，把赋值语句的前后两个值都记录下来，投入buffer队列
        c. buffer 攒满之后， 批量刷到扫描队列（置为 灰色）

    2. 写屏障是一段编译器插入的特殊代码，在编译期间插入，代码函数名字叫做 gcWriteBarrier
        这个函数只做两个事情：
            第一件事: 执行写请求
            第二件事: 处理GC相关的逻辑

        伪代码如下：
            if runtime.writeBarrier.enabled {
                runtime.gcWriteBarrier(ptr, val)
            } else {
                *ptr = val
            }

    3. 屏障代码并不是直接运行，也是要条件判断的，并不是只要是堆上内存赋值就会运行 gcWriteBarrier代码，而是要有一个条件判断。
        这个条件判断是垃圾回收器扫描开始前，stw 程序给设置上去的;
        Note: 所以平时对于堆上内存的赋值，多了一次写操作











